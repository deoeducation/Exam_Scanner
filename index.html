<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMR Scanner Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" id="opencv-js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); padding: 1.5rem; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loader-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="loader-overlay">
        <div class="loader"></div>
        <p id="loader-text" class="mt-4 text-lg">Loading OpenCV...</p>
    </div>

    <div class="max-w-7xl mx-auto space-y-8">
        <header class="text-center">
            <h1 class="text-4xl font-bold text-gray-800">üìÑ OMR Scanner Pro</h1>
            <p class="text-lg text-gray-600 mt-2">A high-accuracy, browser-based scanner for your OMR sheets.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Settings & Uploads Column -->
            <section class="lg:col-span-1 space-y-6">
                <div class="card">
                    <h2 class="text-2xl font-semibold text-gray-700 border-b pb-2">‚öôÔ∏è Settings</h2>
                    <div class="space-y-4 mt-4">
                        <div>
                            <label for="teacher_name" class="block text-sm font-medium text-gray-700">Teacher's Name</label>
                            <input type="text" id="teacher_name" value="Teacher" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="subject" class="block text-sm font-medium text-gray-700">Subject</label>
                            <select id="subject" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option>Maths</option>
                                <option>English</option>
                                <option>Science</option>
                                <option>History</option>
                            </select>
                        </div>
                        <div>
                            <label for="sensitivity" class="block text-sm font-medium text-gray-700">Bubble Detection Sensitivity (<span id="sensitivity-value">0.25</span>)</label>
                            <input type="range" id="sensitivity" min="0.1" max="0.9" value="0.25" step="0.05" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <p class="text-xs text-gray-500 mt-1">Lower value detects lighter marks.</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-2xl font-semibold text-gray-700 border-b pb-2">üîë Upload Files</h2>
                    <div class="space-y-4 mt-4">
                        <div>
                            <label for="answer-key-file" class="block text-sm font-medium text-gray-700">Answer Key (.json)</label>
                            <input type="file" id="answer-key-file" accept=".json" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100">
                        </div>
                        <div>
                            <label for="omr-sheet-file" class="block text-sm font-medium text-gray-700">OMR Sheet Image</label>
                            <input type="file" id="omr-sheet-file" accept="image/*" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100">
                        </div>
                    </div>
                </div>

                <button id="grade-button" disabled class="w-full bg-gray-400 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-300 cursor-not-allowed">
                    Load OpenCV First
                </button>
            </section>

            <!-- Results Column -->
            <section id="results-section" class="lg:col-span-2 space-y-6 hidden">
                <div class="card">
                    <h2 class="text-2xl font-semibold text-gray-700">üìä Scan Results</h2>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-4 items-center">
                        <div class="md:col-span-1 text-center">
                            <p class="text-lg font-medium text-gray-600">Final Score</p>
                            <p id="final-score" class="text-6xl font-bold text-indigo-600">0 / 50</p>
                            <p id="student-id" class="text-sm text-gray-500 mt-2"></p>
                            <button id="download-button" class="mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">
                                üì• Download Results (.xlsx)
                            </button>
                        </div>
                        <div class="md:col-span-2">
                             <h3 class="text-center font-semibold text-gray-600 mb-2">Graded Answer Sheet</h3>
                            <canvas id="output-canvas" class="w-full border-2 border-gray-200 rounded-lg"></canvas>
                        </div>
                    </div>
                </div>

                <div class="card">
                     <h2 class="text-2xl font-semibold text-gray-700">üìã Detailed Answers</h2>
                     <div id="results-table-container" class="mt-4 overflow-x-auto"></div>
                </div>
            </section>

             <section id="placeholder-section" class="lg:col-span-2 flex items-center justify-center card">
                <div class="text-center text-gray-500">
                    <p class="text-2xl">Results will be displayed here</p>
                    <p>Please upload your files and click "Grade Sheet"</p>
                </div>
            </section>
        </main>
    </div>

    <script>
        // --- OPENCV LOADING HANDLERS (GLOBAL SCOPE) ---
        function onOpenCvReady() {
            const loaderOverlay = document.getElementById('loader-overlay');
            const gradeButton = document.getElementById('grade-button');
            loaderOverlay.classList.add('hidden');
            gradeButton.disabled = false;
            gradeButton.textContent = 'Grade Sheet';
            gradeButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
            gradeButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }

        function onOpenCvError() {
            const loaderText = document.getElementById('loader-text');
            loaderText.textContent = 'Failed to load OpenCV. Please check your internet connection.';
        }

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const gradeButton = document.getElementById('grade-button');
            const loaderOverlay = document.getElementById('loader-overlay');
            const loaderText = document.getElementById('loader-text');
            const sensitivitySlider = document.getElementById('sensitivity');
            const sensitivityValue = document.getElementById('sensitivity-value');
            const answerKeyInput = document.getElementById('answer-key-file');
            const omrSheetInput = document.getElementById('omr-sheet-file');
            const resultsSection = document.getElementById('results-section');
            const placeholderSection = document.getElementById('placeholder-section');

            let answerKey = null;
            let omrImage = null;

            // --- EVENT LISTENERS ---
            sensitivitySlider.oninput = () => {
                sensitivityValue.textContent = sensitivitySlider.value;
            };

            answerKeyInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        answerKey = JSON.parse(event.target.result);
                    } catch (err) {
                        alert('Invalid JSON file for answer key.');
                        answerKey = null;
                    }
                };
                reader.readAsText(file);
            };

            omrSheetInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    omrImage = new Image();
                    omrImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            };

            gradeButton.onclick = () => {
                if (!answerKey || !omrImage) {
                    alert('Please upload both the answer key and the OMR sheet image.');
                    return;
                }
                processOMR(omrImage, answerKey, parseFloat(sensitivitySlider.value));
            };

            // --- MAIN OMR PROCESSING FUNCTION ---
            async function processOMR(imageElement, answer_key, sensitivity) {
                loaderText.textContent = 'Processing Image...';
                loaderOverlay.classList.remove('hidden');

                try {
                    let src = cv.imread(imageElement);
                    let gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    let blurred = new cv.Mat();
                    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    let edged = new cv.Mat();
                    cv.Canny(blurred, edged, 50, 150, 3, false);
                    
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let docCnt = null;
                    let maxArea = 0;
                    for (let i = 0; i < contours.size(); ++i) {
                        let cnt = contours.get(i);
                        let area = cv.contourArea(cnt);
                        if (area > maxArea) {
                            let peri = cv.arcLength(cnt, true);
                            let approx = new cv.Mat();
                            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                            if (approx.rows === 4) {
                                docCnt = approx;
                                maxArea = area;
                            }
                            approx.delete();
                        }
                        cnt.delete();
                    }

                    if (docCnt === null) {
                       throw new Error("Could not find the 4 corners of the OMR sheet.");
                    }
                    
                    const points = [
                        { x: docCnt.data32S[0], y: docCnt.data32S[1] },
                        { x: docCnt.data32S[2], y: docCnt.data32S[3] },
                        { x: docCnt.data32S[4], y: docCnt.data32S[5] },
                        { x: docCnt.data32S[6], y: docCnt.data32S[7] }
                    ];

                    points.sort((a, b) => a.y - b.y);
                    const topPoints = points.slice(0, 2).sort((a, b) => a.x - b.x);
                    const bottomPoints = points.slice(2, 4).sort((a, b) => a.x - b.x);
                    const [tl, tr] = topPoints;
                    const [bl, br] = bottomPoints;

                    const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
                    const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
                    const maxWidth = Math.max(widthA, widthB);
                    const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
                    const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
                    const maxHeight = Math.max(heightA, heightB);

                    const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
                    const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, maxWidth, 0, maxWidth, maxHeight, 0, maxHeight]);
                    const M = cv.getPerspectiveTransform(srcTri, dstTri);
                    
                    let warped = new cv.Mat();
                    cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));

                    let warped_gray = new cv.Mat();
                    cv.cvtColor(warped, warped_gray, cv.COLOR_RGBA2GRAY, 0);
                    let thresh = new cv.Mat();
                    cv.threshold(warped_gray, thresh, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU);

                    let all_contours = new cv.MatVector();
                    cv.findContours(thresh, all_contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let question_bubbles = [];
                    for(let i = 0; i < all_contours.size(); i++) {
                        const c = all_contours.get(i);
                        const rect = cv.boundingRect(c);
                        const aspectRatio = rect.width / rect.height;
                        if (rect.width >= 15 && rect.width <= 40 && rect.height >= 15 && rect.height <= 40 && aspectRatio >= 0.8 && aspectRatio <= 1.2 && rect.y > maxHeight * 0.4) {
                           question_bubbles.push(c);
                        } else {
                           c.delete();
                        }
                    }

                    if (question_bubbles.length < 200 * 0.9) {
                        throw new Error(`Found only ${question_bubbles.length} bubbles, expected 200. Image may be blurry.`);
                    }
                    
                    const all_bubble_points_js = question_bubbles.map(c => {
                        const rect = cv.boundingRect(c);
                        return [
                            [rect.x, rect.y],
                            [rect.x + rect.width, rect.y],
                            [rect.x, rect.y + rect.height],
                            [rect.x + rect.width, rect.y + rect.height]
                        ];
                    }).flat(2);

                    const allPointsMat = cv.matFromArray(all_bubble_points_js.length, 1, cv.CV_32SC2, all_bubble_points_js.flat());
                    const cropRect = cv.boundingRect(allPointsMat);
                    allPointsMat.delete();

                    const padding = 10;
                    cropRect.x = Math.max(0, cropRect.x - padding);
                    cropRect.y = Math.max(0, cropRect.y - padding);
                    cropRect.width = Math.min(warped.width - cropRect.x, cropRect.width + padding * 2);
                    cropRect.height = Math.min(warped.height - cropRect.y, cropRect.height + padding * 2);

                    let answer_block = warped.roi(cropRect);
                    let answer_block_thresh = thresh.roi(cropRect);

                    let final_contours = new cv.MatVector();
                    cv.findContours(answer_block_thresh, final_contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    let final_question_bubbles = [];
                    for(let i = 0; i < final_contours.size(); i++) {
                        const c = final_contours.get(i);
                        const rect = cv.boundingRect(c);
                        const aspectRatio = rect.width / rect.height;
                         if (rect.width >= 15 && rect.height >= 15 && aspectRatio >= 0.8 && aspectRatio <= 1.2) {
                            final_question_bubbles.push(c);
                        } else {
                            c.delete();
                        }
                    }

                    if (final_question_bubbles.length !== 200) {
                        throw new Error(`Found ${final_question_bubbles.length} bubbles in final crop, expected 200.`);
                    }

                    final_question_bubbles.sort((a, b) => cv.boundingRect(a).y - cv.boundingRect(b).y);

                    let correct_count = 0;
                    let results = {};
                    let overlay_img = answer_block.clone();

                    for (let i = 0; i < 10; i++) {
                        const row_bubbles = final_question_bubbles.slice(i * 20, (i + 1) * 20);
                        row_bubbles.sort((a, b) => cv.boundingRect(a).x - cv.boundingRect(b).x);
                        for (let j = 0; j < 5; j++) {
                            const question_num = (i + 1) + (j * 10);
                            const question_choices = row_bubbles.slice(j * 4, (j + 1) * 4);
                            
                            let marked_index = -1;
                            let max_filled = 0;

                            for (let k = 0; k < question_choices.length; k++) {
                                let mask = cv.Mat.zeros(answer_block_thresh.rows, answer_block_thresh.cols, cv.CV_8U);
                                let contoursVec = new cv.MatVector();
                                contoursVec.push_back(question_choices[k]);
                                cv.drawContours(mask, contoursVec, 0, new cv.Scalar(255), -1);
                                
                                let masked_thresh = new cv.Mat();
                                cv.bitwise_and(answer_block_thresh, mask, masked_thresh);
                                
                                const total_pixels = cv.countNonZero(masked_thresh);
                                if (total_pixels > max_filled) {
                                    max_filled = total_pixels;
                                    marked_index = k;
                                }
                                mask.delete();
                                contoursVec.delete();
                                masked_thresh.delete();
                            }

                            let marked_answer = null;
                            if (marked_index !== -1 && max_filled > (cv.contourArea(question_choices[marked_index]) * sensitivity)) {
                                marked_answer = "ABCD"[marked_index];
                            }

                            const question_num_str = String(question_num);
                            const correct_answer = answer_key[question_num_str];
                            results[question_num_str] = marked_answer;

                            if (marked_index !== -1) {
                                let color;
                                if (marked_answer === correct_answer) {
                                    correct_count++;
                                    color = new cv.Scalar(0, 255, 0, 255); // Green
                                } else {
                                    color = new cv.Scalar(255, 0, 0, 255); // Red
                                }
                                let contoursVec = new cv.MatVector();
                                contoursVec.push_back(question_choices[marked_index]);
                                cv.drawContours(overlay_img, contoursVec, 0, color, 2);
                                contoursVec.delete();
                            }
                        }
                    }

                    displayResults(results, correct_count, overlay_img);
                    
                    // Memory cleanup
                    src.delete(); gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
                    M.delete(); warped.delete(); warped_gray.delete(); thresh.delete();
                } catch (error) {
                    alert(`An error occurred: ${error.message}`);
                    console.error(error);
                } finally {
                    loaderOverlay.classList.add('hidden');
                }
            }
            
            function displayResults(results, score, overlay_img) {
                // Show results section
                placeholderSection.classList.add('hidden');
                resultsSection.classList.remove('hidden');

                // Update score
                document.getElementById('final-score').textContent = `${score} / 50`;
                const teacherName = document.getElementById('teacher_name').value.replace(' ', '_');
                const studentId = `${teacherName}_${new Date().toISOString().replace(/[-:.]/g, "")}`;
                document.getElementById('student-id').textContent = `Student ID: ${studentId}`;

                // Display graded image
                cv.imshow('output-canvas', overlay_img);
                overlay_img.delete();

                // Create and display detailed table
                const tableContainer = document.getElementById('results-table-container');
                let tableHTML = '<table class="min-w-full divide-y divide-gray-200"><thead><tr>';
                const headers = ["Qn", "Ans", "Key", " "];
                headers.forEach(h => tableHTML += `<th class="px-2 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${h}</th>`);
                tableHTML += '</tr></thead><tbody class="bg-white divide-y divide-gray-200">';
                for(let i = 1; i <= 50; i++) {
                    const qn = String(i);
                    const studentAns = results[qn] || 'N/A';
                    const correctAns = answerKey[qn];
                    const isCorrect = studentAns === correctAns;
                    tableHTML += `<tr>
                        <td class="px-2 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${qn}</td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm ${isCorrect ? 'text-green-600' : 'text-red-600'}">${studentAns}</td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm text-gray-500">${correctAns}</td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm">${isCorrect ? '‚úÖ' : '‚ùå'}</td>
                    </tr>`;
                }
                tableHTML += '</tbody></table>';
                tableContainer.innerHTML = tableHTML;
                
                // Setup download button
                document.getElementById('download-button').onclick = () => {
                    const sortedResults = {};
                    for(let i=1; i<=50; i++) {
                        sortedResults[String(i)] = results[String(i)];
                    }
                    const data = [{
                        "Student": studentId,
                        ...sortedResults,
                        "Total Correct": score
                    }];
                    const worksheet = XLSX.utils.json_to_sheet(data);
                    const workbook = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(workbook, worksheet, "Results");
                    const subject = document.getElementById('subject').value;
                    XLSX.writeFile(workbook, `results_${subject}_${studentId}.xlsx`);
                };
            }
        });
    </script>
</body>
</html>

